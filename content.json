[{"title":"Intro & Foreword (2020 ver) | 简介与前言（二〇二〇年）","date":"2020-11-14T12:37:21.000Z","path":"2020/11/Intro-and-Foreword-2020/","text":"花白（はなしろ）（@hnsr0327），十九岁计科学生，自学金融（着重学衍生品内容），非二元性别。 好久没更新了，所以这里是打算重启，写一份新的个人介绍和“为什么要整这么一个个人主页”。 零一年出生，男生，非二元性别； 能流畅使用简体中文，英语哑巴（不会说，但能打字），其它语言完全不会； 现在在某个本科院校的计算机学院就读，但是也有自学金融中的投资学； 对Cryptocurrency（加密货币）颇有兴趣，不过只在一六年以后开始实际接触； 前两项加在一起：沉迷于近几个月爆发的DeFi（去中心化经济）热潮； 消费电子爱好者，一直打算装机但没有成功自己DIY一套出来； 高中参与过化学竞赛和信息竞赛，但是没能拿足够参加自主招生的奖项； MBTI: INFP-T （于当日完成测试）； MMPI: Hs56 Pd70 Pt67 Sc61 Ma48 Mf-M57 D82 Hy75 Pa55 Si61 （于当日完成测试）； 看过一点点动画，对目前的动漫作品几乎不了解； 在国际服万智牌竞技场里打牌。（Hnsr#03444）。 希望能记录一些学习和“做自己感兴趣的事儿”的内容； 还有日常的开心/难过的事儿； 如果想得起来的话，或许会记录一些回忆？ 图片均已压缩，原图统一为”/pictures/***-origin.**”总消耗不会超过1Mbyte（不像隔壁Broca）的2333(目前是50倍x)）。部分图片/音频/文字会以注释形式给出链接（或直接以内容形式提供）。","tags":[{"name":"个人简介","slug":"个人简介","permalink":"http://yoursite.com/tags/个人简介/"}]},{"title":"Binance Funding Fee Arbitrage | 币安交易所资金费率套利策略","date":"2020-07-28T07:05:05.000Z","path":"2020/07/Binance-Funding-Fee-Arbitrage/","text":"如题。 假设你已经了解跨期套利的概念，或者你也可以看下面一行的简单描述：跨期套利是套利策略中较为普遍的一种，即在同一合约品种的不同月份的合约上建立数量相等、方向相反的交易头寸，最后以对冲或交割方式结束交易、获得收益的方式。 以及，对本文讲解的套利对象做一个描述：币安交易所的永续合约：一种永远不会实际交割的合约，或者说，是一种每隔8个小时就会自动结算并展期的合约。 永续合约的市场受情绪和买卖力度影响（相比于现货市场）更大，在永续合约和其对标的现货市场中有一定的价差（正或者负）。而我们的策略也很简单：卖出高估的永续合约并购买相等数量的现货（反之，买入低估的永续合约并杠杆卖出相等数量的现货）。 虽然这个策略足够简单，笔者在向同学描述的时候时常被质疑“该策略是否能在一个足够有效的市场中运行”。实际上直至今日，加密货币市场仍然是严重情绪化的（换句话说，它是非有效市场）。","tags":[{"name":"交易策略","slug":"交易策略","permalink":"http://yoursite.com/tags/交易策略/"}]},{"title":"SICP 1-3 Exercise | SICP第一章第三节习题","date":"2020-04-25T14:30:27.000Z","path":"2020/04/SICP-1-3-Exercise/","text":"花白的SICP之旅（3） 用高阶函数做抽象本节展示了高阶过程（操作过程的过程）如何能成为强有力的抽象机制，极大增强该语言的表述能力。 过程作为参数以下为本节的示例代码 (define (sum-integers a b) (if (&gt; a b) 0 (+ a (sum-integers (inc a) b))));从a加到b，注意观察形式 (define (sum-cubes a b) (if (&gt; a b) 0 (+ (cube a) (sum-cubes (inc a) b))));从a^3加到b^3，注意观察形式 (define (sum-pi a b);书上是pi-sum (if (&gt; a b) 0 (+ (/ 1.0 (* a (+ a 2))) (sum-pi (+ a 4) b))));非常缓慢地收敛到Π/8，注意观察形式 (define (&lt;name&gt; a b) (if (&gt; a b) 0 (+ (&lt;term&gt; a) (&lt;name&gt; (&lt;next&gt; a) b))));公共模式 (define (sum term a next b) (if (&gt; a b) 0 (+ (term a) (sum term (next a) next b))));“表达求和的概念” (define (sum-cubes a b) (sum cube a inc b)) (define (sum-pi a b) (define (term x) (/ 1.0 (* a (+ a 2)))) (define (next x) (+ x 4)) (sum term a next b)) (define (integral f a b dx);求f函数在a到b之间的定积分近似值 (define (add-dx x) (+ x dx)) (* (sum f (+ a (/ dx 2.0)) add-dx b) dx)) &gt;(integral cube 0 1 0.01);求f=x^3在(0,1)的定积分值 0.24998750000000042 1.29辛普森规则是另一种比上面所用规则更精确的数值积分方法。函数f在范围a和b之间的定积分的近似值是h/3(y0+4y1+2y2……+2y(n-2)+4y(n-1)+yn)，其中h=(b-a)/n（n是一个偶数），yk=f(a+kh)。请定义一个过程，它有参数f、a、b和n，采用辛普森规则计算并返回积分值。用你的过程计算cube在(0,1)的积分（用n=100和n=1000），并将得到的值与示例代码中integral过程得到的值做对比 (define (cube x) (* x x x)) (define (sum term a next b) (if (&gt; a b) 0 (+ (term a) (sum term (next a) next b)))) (define (simpson f a b n) (define h (/ (- b a) n)) (define (add x) (+ (* 2 h) x)) (* (+ (f a) (f b) (* 4 (sum f (+ a h) add (- b h))) (* 2 (sum f (+ a (* 2 h)) add (- b (* 2 h)))) ) (/ h 3) 1.0) ) &gt;(simpson cube 0 1 100) &gt;(simpson cube 0 1 1000) 0.25 0.25;可以说很准了，但是有一点小疑问，为什么参数是十进制数的时候就会很不准 1.30示例代码的sum过程是一个线性递归。请写一个迭代的sum过程。你可以填充下面定义中缺少的表达式来完成这个工作： (define (sum-iter term a next b) (define (iter a result) (if &lt;??&gt; &lt;??&gt; (iter &lt;??&gt; &lt;??&gt;))) (iter &lt;??&gt; &lt;??&gt;)) (define (sum-iter term a next b);1.30 迭代版sum (define (iter a result) (if (&gt; a b) result (iter (next a) (+ result (term a))))) (iter a 0)) &gt;(simpson-iter cube 0 1 1000);用sum-iter重写的辛普森 0.25 &lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;Code&quot; data-labels_right=&quot;:&quot; data-labels_copy=&quot;&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;&lt;/a&gt;&lt;/p&gt; *接下来的三个练习，意图是阐释用一个适当的抽象整理许多看起来毫无关系的操作，从而获得巨大的表达能力。虽然“累积”和“过滤器”都是很优美的想法，但我们不急于将它们用在这里——因为我们还没有数据结构的思想，无法用他们去提供组合这些抽象的适当手段。我们将在2.2.3节回到这些思想，那时候将会说明如何用序列的概念作为界面，组合过滤器和累积，从而构造出强大得多的抽象。我们会在那时候看到，这些方法本身如何能成为设计程序的强有力而又非常优美的途径。1.31a)过程sum是可以用高阶过程表示的大量类似抽象中最简单的一个。请写出一个类似的称为product的过程，它返回在给定范围中各点的某个函数值的乘积。请说明如何用product定义factorial。另请按照下面公式计算Π的近似值：Π/4=2·4·4·6·6·8···/3·3·5·5·7·7···b)你的product过程不是递归就是迭代。请写出另一种product过程。 (define (product term a next b) (if (&gt; a b) 1 (* (product term (next a) b next) (term a)))) (define (factorial x);用product定义的factorial (define (eq x) x) (product eq 1 inc x)) (define (sum-pi-2 x) (define (f x) (/ (* (* x 2) (+ (* x 2) 2)) (* (+ (* x 2) 1) (+ (* x 2) 1))) ) (* 4.0 (product f 1 inc x))) (define (product-iter term a next b) (define (iter a result) (if (&gt; a b) result (iter (next a) (* result (term a))))) (iter a 1)) (define (factorial-iter x) (define (eq x) x) (product-iter eq 1 inc x)) 1.32a)请说明，sum和product（练习1.31）都是另一个被称为accumulate的更一般概念的特殊情况，accumulate使用某些一般性的累积函数组成一系列项： (accumulate combiner null-value term a next b) accumulate取的是和sum/product一样的项和范围描述参数，再加上一个（两个参数的）combiner过程，它描述如何将当前项与前面各项的积累结果组合起来，另外还有一个null-value参数，它描述在所有的项都用完时的基本值。请写出accumulate，并说明我们能怎样基于简单地调用accumulate，定义出sum和product来。b)你的accumulate过程不是递归就是迭代。请写出另一种accumulate过程。 (define (accumulate combiner null-value term a next b) (if (&gt; a b) null-value (combiner (accumulate combiner null-value term (next a) next b) (term a)) ) ) (define (sum-acc term a next b) (accumulate + 0 term a next b)) (define (product-acc term a next b) (accumulate * 1 term a next b)) (define (factorial-acc x) (define (eq x) x) (product-acc eq 1 inc x)) (define (accumulate-iter combiner null-value term a next b) (define (iter a result) (if (&gt; a b) result (iter (next a) (combiner result (term a))))) (iter a null-value)) 1.33你可以通过引进一个处理被组合项的过滤器（filter）概念，写出一个比accumulate（练习1.32）更一般的版本。也就是说，在计算过程中，只组合起有给定范围得到的项里的那些满足特定条件的项。这样得到的filtered-accumulate抽象取与上面累积过程同样的参数，再加上一个另外的描述过滤器的谓词参数。请写出filtered-accumulate过程，并说明如何用filtered-accumulate表达以下内容：a)求出在区间a到b中所有素数之和；b)小于n的所有与n互素的正整数之乘积。 (define (filtered-accumulate filter combiner null-value term a next b) (if (&gt; a b) null-value (if (filter a) (combiner (filtered-accumulate filter combiner null-value term (next a) next b) (term a)) (filtered-accumulate filter combiner null-value term (next a) next b) ))) (define (filtered-accumulate-iter filter combiner null-value term a next b) (define (iter a result) (if (&gt; a b) result (if (filter a) (iter (next a) (combiner result (term a))) (iter (next a) result) ))) (iter a null-value)) (define (prime-filter-acc a b) (define (eq x) x) (filtered-accumulate prime? + 0 eq a inc b)) (define (gcd1? a b) (if (= 1 (gcd a b)) true false)) (define (gcd1-filter-acc n) (define (eq x) x) (filtered-accumulate (lambda (x) (gcd1? x n)) * 1 eq 1 inc (- n 1))) 用lambda构造过程以下为本节的示例代码 (lambda (x) (+ x 4));“那个返回其输入值加4的过程” (lambda (x) (/ 1.0 (* x (+ x 2))));“那个返回其输入与它加2的乘积的倒数的过程” (define (plus4 x) (+ x 4));define和λ的唯一区别是λ没有和环境中的任何名字相关联 (define plus4 (lambda (x) (+ x 4))) (lambda;这是一个过程 (x);它以x为参数 (+ x 4);它把x和4加起来 ) &gt;(lambda (x y z) (+ x y (* z z)) 1 2 3) 12 (define (f x y);我们以前用辅助过程来约束局部变量 (define (f-helper a b) (+ (* x (square a)) (* y b) (* a b))) (f-helper (+ 1 (* x y)) (- 1 y))) (define (f x y);我们还可以用lambda描述约束局部变量的匿名过程 ((lambda (a b) (+ (* x (square a)) (* y b) (* a b))) (+ 1 (* x y)) (- 1 y))) (define (f x y);现在，我们可以用let将名字和表达式进行“对偶” (let ((a (+ 1 (* x y))) (b (- 1 y))) (+ (* x (square a)) (* y b) (* a b)))) ;其实let是lambda的语法糖 (define x 5) &gt;(+ (let ((x 3)) (+ x (* x 10))) x);位于let体内的x值是3，外部的x值仍然是5 38 &gt;(let ((x 3) (y (+ x 2))) (* x y)) 21;x*y的x是let定义后的，而let定义的y使用的x是外面的5 1.34我们定义了过程f，然后有示例输入输出： (define (f g) (g 2)) &gt;(f square) 4 &gt;(f (lambda z (* z (+ z 1)))) 6 我们坚持要求解释器取求值(f f)，那么我们会看到什么情况，为什么？ &gt;(f f) (f (lambda (g) (g 2))) ((lambda (g) (g 2)) 2) (2 2);2不是一个过程名 ;application: not a procedure; ;expected a procedure that can be applied to arguments ; given: 2 ; arguments: 2 过程作为一般性的方法 (define (search f neg-point pos-point);区间折半使用的减半策略 (let ((midpoint (average neg-point pos-point))) (if (close-enough? neg-point pos-point) midpoint (let ((test-value (f midpoint))) (cond ((positive? test-value) (search f neg-point midpoint)) ((negative? test-value) (search f midpoint pos-point)) (else midpoint)))))) (define (close-enough? x y) (&lt; (abs (- x y)) 0.001)) (define (half-interval-method f a b);区间折半 (let ((a-value (f a)) (b-value (f b))) (cond ((and (negative? a-value) (positive? b-value)) (search f a b)) ((and (negative? b-value) (positive? a-value)) (search f b a)) (else (error &quot;Values are not of opposite sign&quot; a b))))) ;: (half-interval-method sin 2.0 4.0) ;: (half-interval-method (lambda (x) (- (* x x x) (* 2 x) 3)) ;: 1.0 ;: 2.0) ;; Fixed points (define tolerance 0.00001) (define (fixed-point f first-guess) (define (close-enough? v1 v2) (&lt; (abs (- v1 v2)) tolerance)) (define (try guess) (let ((next (f guess))) (if (close-enough? guess next) next (try next)))) (try first-guess)) ;: (fixed-point cos 1.0) ;: (fixed-point (lambda (y) (+ (sin y) (cos y))) ;: 1.0) (define (sqrt-1 x) (fixed-point (lambda (y) (/ x y)) 1.0)) (define (sqrt-2 x) (fixed-point (lambda (y) (average y (/ x y))) 1.0)) 1.35请证明黄金分割率φ是变换x→1+1/x的不动点。并利用这一事实，用过程fixed-point计算出φ的值。 ;: φ^2=φ+1 -&gt; φ=1+1/φ &gt;(fixed-point (lambda (x) (+ 1 (/ 1 x))) 1) 1+377/610 (1.61803) 1.36请修改fixed-point，利用练习1.22展示的newline和display基本过程，使它打印出计算中产生的近似值序列。然后用它找出x→log(1000)/log(x)的不动点（即确定x^x=1000的一个根）。同时，请比较使用平均阻尼和非平均阻尼的计算步数。 (define (fixed-point-1-36 f first-guess) (define (close-enough? v1 v2) (&lt; (abs (- v1 v2)) tolerance)) (define (try guess i) (display-formatter guess i) (let ((next (f guess))) (if (close-enough? guess next) (begin (display-formatter guess (+ i 1)) next) (try next (+ i 1))))) (try first-guess 1)) (define (display-formatter a b) (display a) (display &quot; &quot;) (display b) (newline)) &gt; (fixed-point-1-36 (lambda (x) (/ (log 1000) (log x))) 1.1) 1.1 1 72.47657378429035 2 1.6127318474109593 3 14.45350138636525 4 2.5862669415385087 5 ;:略过 4.555552779647764 34 4.555524444961165 35 4.555543131130589 36 4.555530807938518 37 4.555530807938518 38 4.555538934848503 &gt; (fixed-point-1-36 (lambda (x) (/ (+ x (/ (log 1000) (log x))) 2)) 1.1) 1.1 1 36.78828689214517 2 19.352175531882512 3 10.84183367957568 4 6.870048352141772 5 ;:略过 4.5563204194309606 10 4.555669361784037 11 4.555558462975639 12 4.55553957996306 13 4.55553957996306 14 4.555536364911781 ;:非平均阻尼要更慢一点 1.37a)已知有一个无穷连分式（维基百科），作为一个例子，我们可以证明，当其中的分子数字和分母数字都等于1时，它将产生1/φ，φ是上面题目中的黄金分割率。逼近某个无穷连分式的一个方法是：在k项后面截断，这个截断叫做k项有限连分式。假定n和d都是只有一个参数（项下标i）的过程，它们分别返回连分式的分子数字和分母数字。请定义一个过程cont-frac，使得对(cont-frac n d k)的求值计算出k项有限连分式的值。你需要取多大的k才能保证得到的近似值具有十进制的4位精度？b)你的cont-frac过程不是递归就是迭代。请写出另一种cont-frac过程。 ;:递归 (define (cont-frac-rec n d k) (define (rec i) (if (= k i) (/ (n k) (d k)) (/ (n i) (+ (d i) (rec (+ i 1)))))) (rec 1) ) ;:k&gt;=11时有4位精度 &gt; (cont-frac-rec (lambda (i) 1.0) (lambda (i) 1.0) 11) (cont-frac-rec (lambda (i) 1.0) (lambda (i) 1.0) 1000) 0.6180555555555556 0.6180339887498948 ;:迭代 (define (cont-frac-iter n d k) (define (iter i result) (if (= i 1) (/ (n 1) (+ (d 1) result)) (iter (- i 1) (/ (n i) (+ (d i) result))))) (iter k 0) ) 1.38在1737年，瑞士数学家莱昂哈德·欧拉发表了一篇论文，其中包含了e-2的一个连分式展开。在这一分式中，Ni全都是1，D1依次为1,2,1,1,4,1,1,6,1,1,8,…。请写出一个程序，其中使用了1.37所做的cont-frac过程，并能基于该展开式求出e的近似值。 (define (cont-frac-iter n d k) (define (iter i result) (if (= i 1) (/ (n 1) (+ (d 1) result)) (iter (- i 1) (/ (n i) (+ (d i) result))))) (iter k 0) ) &gt; (cont-frac-iter (lambda (x) 1.0) (lambda (x) (if (= (remainder x 3) 2) (+ (* (quotient x 3) 2) 2) 1)) 100) 0.7182818284590453 1.39正切函数的连分式表示由德国数学家J.H. Lambert在1770年发表。请定义过程(tan-cf x k)，它基于Lambert公式计算正切函数的近似值。（k是计算的项数，就像1.37一样） (define (cont-frac-iter n d k) (define (iter i result) (if (= i 1) (/ (n 1) (+ (d 1) result)) (iter (- i 1) (/ (n i) (+ (d i) result))))) (iter k 0) ) (define (tan-cf x k) (cont-frac-iter (lambda (i) (if (= i 1) x (- (* x x)))) (lambda (i) (- (* i 2) 1)) k)) &gt; (tan-cf (/ 3.1415926535 4) 1000) 0.9999999999551035 过程作为返回值 (define (average-damp f);:平均阻尼的**思想** (lambda (x) (average x (f x)))) &gt; ((average-damp square) 10) 55 (define (sqrt x);:三种思想，一个方法 (fixed-point (average-damp (lambda (y) (/ x y))) 1.0)) (define (cube-root x) (fixed-point (average-damp (lambda (y) (/ x (square y)))) 1.0)) (define (deriv g) (define dx 0.00001) (lambda (x) (/ (- (g (+ x dx)) (g x)) dx))) &gt; ((deriv (lambda (x) (* x x x))) 5);:f(x)=x^3在x=5的导数 75.00014999664018 (define (newton-transform g) (lambda (x) (- x (/ (g x) ((deriv g) x))))) (define (newtons-method g guess);:新牛顿法（求不动点的过程） (fixed-point (newton-transform g) guess)) (define (sqrt x) (newtons-method (lambda (y) (- (square y) x)) 1.0)) (define (fixed-point-of-transform g transform guess) (fixed-point (transform g) guess)) (define (sqrt x) (fixed-point-of-transform (lambda (y) (/ x y)) average-damp 1.0)) (define (sqrt x) (fixed-point-of-transform (lambda (y) (- (square y) x)) newton-transform 1.0)) 1.40请定义一个过程cubic，它和newtons-method过程一起使用在下面形式的表达式里： (newtons-method (cubic a b c) 1) 能逼近三次方程x^3+ax^2+bx+c的零点。","tags":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/tags/计算机/"}]},{"title":"SICP 1-2 Exercise | SICP第一章第二节习题","date":"2020-04-19T06:57:12.000Z","path":"2020/04/SICP-1-2-Exercise/","text":"花白的SICP之旅（2） 过程和产生的计算我们考察了一些简单过程产生的计算过程的“形状”，同时研究这些计算过程消耗各种重要计算资源（时间和空间）的“速率”。这一节的过程都是非常简单的，它们扮演的角色相当于摄影术的测试模式——极度简化且本身并不实际。 1.9下面这两个过程各定义了一种加法，它们基于过程inc（它将参数加1）和dec（它将参数减1） (define (+1 a b) (if (= a 0) b (inc (+1 (dec a) b)))) (define (+2 a b) (if (= a 0) b (+2 (dec a) (inc b)))) 请用代换模型展示这两个过程在求值(+ 4 5)时所产生的计算过程。这些计算过程是递归的/迭代的吗？第一个过程是这样的，是递归计算过程计算过程中有“伸展”和“收缩”的过程，且伸展过程所需要的计算量和存储空间都和参数有关 (+ 4 5) (inc (+ 3 5)) (inc (inc (+ 2 5))) (inc (inc (inc (+ 1 5)))) (inc (inc (inc (inc (+ 0 5))))) (inc (inc (inc (inc 5)))) (inc (inc (inc 6))) (inc (inc 7)) (inc 8) 9 第二个过程是这样的，是迭代计算过程计算过程中没有上述过程，需要的存储空间是常数项，计算量和参数有关 (+ 4 5) (+ 3 6) (+ 2 7) (+ 1 8) (+ 0 9) 9 1.10下面这个过程计算一个称为Ackermann函数的数学函数： (define (A x y) (cond ((= y 0) 0) ((= x 0) (* 2 y)) ((= y 1) 2) (else (A (- x 1) (A x (- y 1)))))) 请求(A 1 10)(A 2 4)(A 3 3)，并给出下面的过程对给定整数值n所计算的函数的数学定义 (define (f n) (A 0 n)) (define (g n) (A 1 n)) (define (h n) (A 2 n)) (A 1 10)、(A 2 4)和(A 3 3)过程如下： &gt;(A 1 10) (A 0 (A 1 9)) (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1)))))))))) (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2))))))))) 1024 &gt;(A 2 4) (A 1 (A 2 3)) (A 1 (A 1 (A 1 (A 2 1)))) (A 1 (A 1 (A 1 2))) (A 1 (A 1 (A 0 (A 1 1)))) (A 1 (A 1 4)) (A 1 16) 65536 &gt;(A 3 3) (A 2 (A 3 2)) (A 2 (A 2 (A 3 1))) (A 2 (A 2 2)) 65536 (f n)=2n，(g n)=2^n，(h n)=2^(2^n))。 1.11函数f由如下规则定义：如果n&lt;3，f(n)=n；否则f(n)=f(n-1)+2*f(n-2)+3*f(n-3)请分别采用递归计算过程和迭代计算过程写计算f(n)的过程。递归计算过程 (define (f x) (cond ((&lt; x 3) x) (else (+ (f (- x 1)) (* 2 (f (- x 2))) (* 3 (f (- x 3))))))) 迭代计算过程 (define (g x3 x2 x1) (+ x3 (* 2 x2) (* 3 x1))) (define (f x) (define (f-iter x1 x2 x3 count mx) (cond ((&lt; mx 3) mx) ((&lt; count mx) (f-iter x2 x3 (g x3 x2 x1) (inc count) mx)) ((= count mx) x2) )) (f-iter 1 2 4 2 x)) 1.12已知有一个杨辉三角，请写一个计算杨辉三角的元素的递归计算过程。 (define (pas row col) (define (fac x) (define (fac-w output count mx) (if (&gt; count mx) output (fac-w (* count output) (inc count) mx))) (fac-w 1 1 x)) (define r (dec row)) (define c (dec col)) (if (or (&gt; col row) (&lt; col 0)) 0 (/ (fac r) (* (fac c) (fac (- r c))))) ) 1.13证明Fib(n)（斐波那契数列的第n项）是最接近((sqrt(5)+1)/2)^n/sqrt(5)的整数。提示：先用数学归纳法证明Fib(n)=(((sqrt(5)+1)/2)^2-((sqrt(5)-1)/2)^2)/sqrt(5) 解图 1.14已知一个“给定任意钱数，给出将其换成(50/25/10/5/1)元的组合方式个数”的过程 (define (count-change amount) (define (value kind-of-coins) (cond ((= kind-of-coins 5) 50) ((= kind-of-coins 4) 25) ((= kind-of-coins 3) 10) ((= kind-of-coins 2) 5) ((= kind-of-coins 1) 1) ) ) (define (cc amount kind-of-coins) (cond ((= amount 0) 1) ((or (&lt; amount 0) (= kind-of-coins 0)) 0) (else (+ (cc amount (dec kind-of-coins)) (cc (- amount (value kind-of-coins)) kind-of-coins) )) ) ) (cc amount 5)) &gt;(count-change 400) 26517 请以树的形式画出“count-change过程在将11元换成硬币时产生的计算过程”这个计算过程的空间和步数增长的阶各是什么？ 计算过程图空间的最大使用量即是树的最大层数，此处层数的快速增长来自(n 1)-&gt;(n 0)+(n-1 1)，很明显空间增长的阶为Θ(n)考察(cc amount x)中x参数对时间复杂度的影响：当x=1时，计算量约为amount*2，此时为Θ(n)；当x=2时，(cc amount 2)会“分裂”成(cc amount 1)和(cc amount-5 2)，也就是说x=2的增长速度相比x=1多了amount倍；当x=3时，(cc amount 3)同样会“分裂”，我们会发现x=n+1的步数增长是x=n的amount倍；即题干中(count-change amount)即(cc amount 5)的步数增长阶为Θ(n^5)。但是在比较小的“找零”中，增长阶并没有达到Θ(n^5) 1.15在弧度制的角x足够小时，其正弦值可以用sinx≈x计算，有三角恒等式sinx=3sin(x/3)-4sin(x/3)^3可以减小sin的参数大小（这道习题以不超过0.1弧度为“足够小”），这个想法体现在下述过程： (define (sine angle) (define (cube x) (* x x x)) (define (p x) (- (* 3 x) (* 4 (cube x)))) (if (not (&gt; (abs angle) 0.1)) angle (p (sine (/ angle 3.0))))) 请问：a)在求值(sine 12.15)时，p调用了多少次？b)在求值(sine a)时，由过程sine所产生的计算过程使用的空间和步数（作为a的函数）增长的阶是什么？ a)12.15-&gt;4.05-&gt;1.35-&gt;0.45-&gt;0.15-&gt;0.05，即p调用了5次；b)易得参数(a)每增长到原来的3倍，递归深度加一，即增长的阶为Θ(logn)。 1.16请定义一个过程，它能产生出一个“按照迭代方式，使用一系列求平方，就像只用对数个步骤的fast-expt”的求幂计算过程。 (define (fast-expt a n) (define (square x) (* x x)) (define (even? n) (= (remainder n 2) 0)) (cond ((= n 0) 1) ((even? n) (square (fast-expt a (/ n 2)))) (else (* a (fast-expt a (- n 1)))))) 提示Ⅰ：请利用好关系(a^(n/2))^2=(a^2)^(n/2)，除了指数n和基数a以外，还应维持一个附加的状态变量b，定义好状态变换，使得状态转移时b*a^n不变。计算开始时b=1，结束时输出b。提示Ⅱ：“定义一个不变量，要求它在状态间保持不变”是思考迭代算法设计问题时的强力方法。 (define (iter-expt a n) (define (square x) (* x x)) (define (even? n) (= (remainder n 2) 0)) (define (expt a n b) (cond ((= n 0) b) ((even? n) (expt (square a) (/ n 2) b)) ((not (even? n)) (expt a (- n 1) (* b a))) ) ) (expt a n 1)) 1.17本节（1.2.4 求幂）的求幂算法的基础是通过反复做乘法求乘幂。类似的是，我们可以通过反复加法的方式求出乘积。下面的乘积过程与expt过程类似（假定该语言没有乘法）： (define (expt b n) (if (= n 0) 1 (* b (expt b (- n 1))))) (define (multi a b) (if (= b 0) 0 (+ a (multi a (- b 1))))) 该算法的计算量相对于b是线性的，假定有过程double（它将参数乘以2）和halve（它将偶数参数除以2），请用+、-、double和halve设计类似1.16的求乘积过程。 (define (multi a b) (define (double n) (+ n n)) (define (halve n) (/ n 2)) (define (even? n) (= (remainder n 2) 0)) (cond ((= b 1) a);a*1=a ((even? b) (multi (double a) (halve b)));a*b=(a*2)*(b/2) (else (+ (multi a (- b 1)) a));a*b=a*(b-1)+a ) ) 1.18请用1.16和1.17的结果，限定（+、-、double、halve），用对数步数求出两个数的乘积（注：此处应是用迭代过程重写1.17过程） (define (iter-multi a b) (define (double n) (+ n n)) (define (halve n) (/ n 2)) (define (even? n) (= (remainder n 2) 0)) (define (multi a b u) (cond ((= b 0) u) ((even? b) (multi (double a) (halve b) u)) (else (multi a (- b 1) (+ u a))))) (multi a b 0)) 1.19存在一种对数步数求Fib(n)的巧妙算法。我们已经知道旧fib-iter过程中a和b的变换规则为a←a+b和b←a，我们现在管这个变换叫T变换。通过观察可以发现，从(a,b)=(1,0)开始做N次T变换，可以得到(a,b)=(Fib(n+1),Fib(n))，换言之斐波那契数可以通过应用于(1,0)的T^n（T变换的n次方）来求得。现在我们重新定义T变换是变换族Tpq的特别种（p=0,q=1），Tpq是(a,b)→(bq+aq+ap,bp+aq)的变换。(a)请证明：如果应用变换Tpq两次，效果相当于应用同样形式的一次变换Tp’q’，其中的p’和q’可以算出来；(b)这指明了求出该变换的平方的路径，我们可以通过连续求平方的方式计算T^n。将1.16~1.18集合在一起，我们可以写出下面的“对数求出Fib(n)”的过程。请补全该过程 (define (fib-old n) (define (fib-iter a b count) (if (= count 0) b (fib-iter (+ a b) a (- count 1)))) (fib-iter 1 0 n)) (define (fib n) (define (fib-iter a b p q count) (cond ((= count 0) b) ((even? count) (fib-iter a b ??FILL-THIS-IN?? ; compute p&#39; ??FILL-THIS-IN?? ; compute q&#39; (/ count 2))) (else (fib-iter (+ (* b q) (* a q) (* a p)) (+ (* b p) (* a q)) p q (- count 1))))) (fib-iter 1 0 0 1 n)) (a)(a,b)→两次Tpq变换→(2bpq+2apq+2aq^2+bq^2+ap^2,2apq+aq^2+bq^2+bp^2)=(bq’+aq’+ap’,bp’+aq’)，观察得p’=p^2+q^2,q’=q^2+2pq。(b)我们现在可以用这个方法了——n是偶数时，求一次变换的平方并减半n，n是奇数时，运用一次变换并减少n。 (define (fib-ultra n) (define (fib-iter a b p q count) (cond ((= count 0) b) ((even? count) (fib-iter a b (+ (* p p) (* q q)) ; compute p&#39; (+ (* q q) (* 2 (* p q))) ; compute q&#39; (/ count 2))) (else (fib-iter (+ (* b q) (* a q) (* a p)) (+ (* b p) (* a q)) p q (- count 1))))) (fib-iter 1 0 0 1 n)) 1.20一个过程所产生的计算过程当然依赖于解释器所使用的规则。考虑这个迭代式gcd过程： (define (gcd a b) (if (= b 0) a (gcd b (remainder a b)))) 假定解释器用书上1.1.5节的正则序（完全展开再归约）解释这一过程（if的求值规则总是“谓词部分先行求值，根据结果再确定随后求的是哪个子表达式”）。请采用正则序的代换方法，展示(gcd 206 40)的计算过程，并指明实际执行的remainder运算。其中实际执行了多少次remainder运算？如果采用应用序（先求值参数再应用）求值呢？ &gt;(gcd 206 40);正则序 (gcd 40 (remainder 206 40));(gcd 40 6) (if (= (remainder 206 40) 0) 40 (gcd (remainder 206 40) (remainder 40 (remainder 206 40))));1次 (gcd (remainder 206 40) (remainder 40 (remainder 206 40)));(gcd 6 4) (if (= (remainder 40 (remainder 206 40)) 0) (remainder 206 40) (gcd (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))));2次 (gcd (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))));(gcd 4 2) (if (= (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) 0) (remainder 40 (remainder 206 40)) (gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))));4次 (gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))));(gcd 2 0) (if (= (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) 0) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) ......));7次 (remainder (remainder 206 40) (remainder 40 (remainder 206 40)));4次 2;总共18次，实际执行的部分有if部分先行求值的14次和最后结果的4次 &gt;(gcd 206 40);应用序 (gcd 40 6);1次 (gcd 6 4);1次 (gcd 4 2);1次 (gcd 2 0);1次 (if (= 0 0) 2 (gcd 0 (remainder 2 0))) 2;总共4次 1.21用smallest-divisor过程找出下面各数的最小因子：199、1999、19999 (define (prime? n) (define (smallest-divisor n) (define (divides? a b) (= (remainder b a) 0)) (define (find-divisor n test-divisor) (cond ((&gt; (square test-divisor) n) n) ((divides? test-divisor n) test-divisor) (else (find-divisor n (+ test-divisor 1))))) (find-divisor n 2)) (= n (smallest-divisor n))) 略（199、1999、7） 1.22大部分Lisp实现都包含一个runtime基本过程，调用它将返回一个整数，表示系统已经运行的时间。对整数n调用下面的timed-prime-test过程时将打印出n并检查n是否为素数。如果n是素数，过程将打印出三个星号和“执行这一检查所用的时间量”。 (define (timed-prime-test n) (newline) (display n) (start-prime-test n (runtime))) (define (start-prime-test n start-time) (if (prime? n) (report-prime (- (runtime) start-time)))) (define (report-prime elapsed-time) (display &quot; *** &quot;) (display elapsed-time)) 请利用这一过程写一个search-for-primes过程，它检查给定范围内连续的各个奇数的素性。请用你写的过程找出大于百/千/万/十万亿的三个最小的素数，并注意其中检查每个素数所需要的时间。已知这一检查算法具有Θ(sqrt(n))的增长阶，你可以期望在千亿附近的素数检查的耗时大约是在百亿附近的素数检查的3.16倍。你得到的数据确实如此吗？那么对于十万亿和万亿得到的数据可以支持这个预测吗？有人说程序在机器上运行的时间正比于计算所需的步数，你得到的结果符合这种说法吗？原题目为1000/10000/100000/1000000，但是由于现在计算机性能高涨，只能加七个0以产生显著影响 (define (timed-prime-test n) (define (start-prime-test n start-time) (define (report-prime elapsed-time n) (newline) (display n) (display &quot; *** &quot;) (display elapsed-time)) (if (prime? n) (report-prime (- (runtime) start-time) n))) (start-prime-test n (runtime))) (define (prime? n) ......);略 (define (search-for-primes a b) (define (primetest i y) (if (not (&gt; i y)) (timed-prime-test i)) (if (not (&gt; i y)) (primetest (+ i 2) y))) (primetest (if (= (remainder a 2) 0) (+ a 1) a) b)) (search-for-primes 10000000000 10000000100);7.0ms (search-for-primes 100000000000 100000000100);20.7ms (search-for-primes 1000000000000 1000000000100);69.2ms (search-for-primes 10000000000000 10000000000100);231.7ms 找素数略耗时的预测在十万亿和千亿/万亿和百亿大致正确。 1.231.21中的smallest-divisor过程做了许多无用检查：在其检测完2以后，不应该再检测任何偶数。我们希望test-divisor所用的值是（2、3、5、7、9……）。请实现这种修改，其中定义一个过程next：输入2时输出3，其他时候输出输入的数加2。运行1.22找素数测试。这一修改使检查的步数少了一半，你可能期待其运行速度快一倍，实际情况符合这一预期吗？如果不符合，两个算法的速度比值是多少？如何解释比值不等于2？ (define (prime? n) (define (smallest-divisor n) (define (next x) (cond ((&gt; x 2) (+ x 2)) (else 3))) (define (divides? a b) (= (remainder b a) 0)) (define (find-divisor n test-divisor) (cond ((&gt; (square test-divisor) n) n) ((divides? test-divisor n) test-divisor) (else (find-divisor n (next test-divisor))))) (find-divisor n 2)) (= n (smallest-divisor n)));外部测时间略 (search-for-primes 10000000000 10000000100);3.8ms (search-for-primes 100000000000 100000000100);13.0ms (search-for-primes 1000000000000 1000000000100);40.9ms (search-for-primes 10000000000000 10000000000100);164.2ms 并不符合该预期，速度比值约为1.5。因为只有这个步骤得到了加速。 1.24修改练习1.22中的timed-prime-test过程，让它使用fast-prime?（费马方法）；运行1.22找素数测试。这一修改让素数测试具有仅仅Θ(logn)的增长速度，你对接近一亿的素数检查和接近一万的素数检查的期望时间比值有何预期？数据表明预期了吗？你能解释不符合预期的地方吗？ (define (search-for-primes a b) (define (timed-prime-test n) (define (fast-prime? n times) (define (fermat-test n) (define (expmod base exp m) (define (square x) (* x x)) (cond ((= exp 0) 1) ((even? exp) (remainder (square (expmod base (/ exp 2) m)) m)) (else (remainder (* base (expmod base (- exp 1) m)) m)) )) (define (try-it a) (= (expmod a n n) a)) (try-it (+ 1 (random (- n 1))))) (cond ((= times 0) true) ((fermat-test n) (fast-prime? n (- times 1))) (else false))) (define (start-prime-test n start-time) (define (report-prime elapsed-time n) (newline) (display n) (display &quot; *** &quot;) (display elapsed-time)) (if (fast-prime? n 10000);被人为调大 (report-prime (- (runtime) start-time) n))) (start-prime-test n (runtime))) (define (primetest i y) (if (not (&gt; i y)) (timed-prime-test i)) (if (not (&gt; i y)) (primetest (+ i 2) y))) (primetest (if (= (remainder a 2) 0) (+ a 1) a) b)) (search-for-primes 10000 10100);23ms (search-for-primes 100000000 100000100);47ms 由这几题可以发现：使用计算步数最多只能“大致预测”程序的运行时间，而算法复杂度是用于评价算法思想“好”的程度的。即使我们计算出来某程序的计算步数，也会由于各种原因——电脑CPU主频的高低、当前系统的拥堵程度、编译器/解释器的优化效率等等——使得计算步数无法对应到最终的运行时间。而算法复杂度更为简单：它估计的是计算步数（空间）的规模随参数的变化而变化的程度。大多数情况下，如果A算法比B算法复杂度低，在参数较小时B可能快于A，但是在参数足够大时，A算法的优势将体现出来。 1.25有人说在费马测试中的expmod中，我们做了很多的额外工作，我们应该这么写expmod： (define (fast-expt a n) (define (square x) (* x x)) (define (even? n) (= (remainder n 2) 0)) (cond ((= n 0) 1) ((even? n) (square (fast-expt a (/ n 2)))) (else (* a (fast-expt a (- n 1)))))) (define (expmod base exp m) (remainder (fast-expt base exp) m)) 请问：这句话对吗？这个过程可以很好地用于我们的快速素数检查程序吗，为什么？不对。我们仔细阅读费马测试中的代码，会发现exp数值有时候会很大（比如数万），此时原版代码将乘幂减少到可以计算的程度再计算，而这里将会粗暴地计算数十亿的数万次方，计算量会大到难以想象。 1.26有人在做练习1.24的时候遇到了困难：他的fast-prime?比原来的prime?还要慢。他的朋友在检查他的代码时发现他重写了expmod过程，其中用了一个乘法代替square过程： (define (expmod base exp m) (define (square x) (* x x)) (cond ((= exp 0) 1) ((even? exp) (remainder (* (expmod base (/ exp 2) m);changed (expmod base (/ exp 2) m)) m)) (else (remainder (* base (expmod base (- exp 1) m)) m)) )) 这个人如此解释：“我看不出来这会造成什么不同。”而朋友一语道破：“你采用这种方式写这个过程时，就把Θ(logn)的过程变成Θ(n)的了。”请解释这段话。让我们假定我们是一台电脑，即将计算(expmod 2 1024 10)若使用旧的expmod过程，我们将会遇到(square (expmod 2 512 10))，只要计算一次下级的expmod；而题干的expmod过程将会让我们计算两次(expmod 2 512 10)。到最后，旧过程约10次能干完，新过程却要1024次才能干完，对数型增长变成了线性增长。 1.27证明脚注47*中列出的Carmichael数确实能骗过费马检查。为了证明这一点，你可以写一个过程，输入整数n，对每个a&lt;n检查a^n是否与a模n同余。*能骗过费马检查的数称为Carmichael数，只知道它非常罕见。在一亿之内只有255个这种数 (define (ultra-prime? n) (define (fermat-test n) (define (expmod base exp m) (define (square x) (* x x)) (cond ((= exp 0) 1) ((even? exp) (remainder (square (expmod base (/ exp 2) m)) m)) (else (remainder (* base (expmod base (- exp 1) m)) m)) )) (define (try-it a) (= (expmod a n n) a)) (try-it (+ 1 (random (- n 1))))) (define (prime? x y n) (cond ((not (&lt; x y)) true) ((not (fermat-test n)) false) (else (prime? (+ x 1) y n)))) (prime? 0 n n));超级素数筛法 (ultra-prime? 561);#t (ultra-prime? 1105);#t (ultra-prime? 1729);#t (ultra-prime? 2465);#t (ultra-prime? 2821);#t (ultra-prime? 6601);#t;超级筛法反而没用了 1.28费马检查的一种不会被欺骗的变形为Miller-Rabin检查，它来源于费马小定理的一个变形。这个变形断言：如果n是素数，那么任何小于a的整数的n-1次幂与1模n同余。要用该检查方法考察n的素性，我们应该随机抽取数a\\&lt;n并用expmod求a的n-1次幂对n的模。然而，在执行expmod中的平方步骤时，我们需要查看是否遇到了“1取模n的非平凡平方根”，也就是说，是不是存在不等于1或者n-1的数，其平方取模n等于1。可以证明，如果1的这种非平凡平方根存在，那么n就不是素数。还可以证明，如果n是非素数的奇数，那么至少有一半的数a\\&lt;n，按照这种方式计算a^(n-1)，将会遇到1取模n的非平凡平方根。这也是该检查不会受骗的原因。请修改expmod过程，让它在发现1的非平凡平方根时报告失败，并利用它实现一个类似于fermat-test的过程，完成Miller-Rabin检查。通过检查一些已知素数和非素数的方式考验你的过程。提示：送出失败信号的一种简单方式就是返回0 (define (prime? x) (define (miller-rabin-prime? n times) (define (square x) (* x x)) (define (ultra-fermat-test n) (define (nontrivial-square-roots? base m) (and (not (= base 1)) (not (= base (- m 1))) (= 1 (remainder (square base) n))) );是不是存在不等于1或者n-1的数，其平方取模n等于1 (define (expmod base exp m) (cond ((nontrivial-square-roots? (+ 1 (random (- n 1))) m) 0);是否遇到非平凡平方根 ((= exp 0) 1) ((even? exp) (remainder (square (expmod base (/ exp 2) m)) m)) (else (remainder (* base (expmod base (- exp 1) m)) m)) )) (define (try-it a) (= (expmod a (- n 1) n) 1)) (try-it (+ 1 (random (- n 1))))) (cond ((= times 0) true) ((ultra-fermat-test n) (miller-rabin-prime? n (- times 1))) (else false)));miller-rabin筛法 (miller-rabin-prime? x (ceiling (sqrt x)))) (prime? 561) (prime? 1105) (prime? 1729) (prime? 2465) (prime? 2821) (prime? 6601);Carmichael 全为#f (prime? 9999749);#t","tags":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/tags/计算机/"}]},{"title":"SICP 1-1 Exercise | SICP第一章第一节习题","date":"2020-04-14T15:09:12.000Z","path":"2020/04/SICP-1-1-Exercise/","text":"花白的SICP之旅（1） 程序设计的基本元素1.1下面是一堆表达式，从上到下解释器将输出什么结果？（表达式略）一系列表达式，按部就班地做就行了 1.2请将下面表达式变换为前缀形式。（表达式略）考察前缀形式表达式 1.3请定义一个过程，它以三个数为参数，返回其中较大的两个数的平方和。（汉化版缺了“平方”） (define (Y a b c) (cond ((and (&lt; c b) (&lt; c a)) (+ a b)) ((and (&lt; b a) (&lt; b c)) (+ a c)) (else (+ b c)))) //平方和的话就是再加一个define 1.4考察允许运算符为符合表达式的组合式的求值模型，根据对模型的认识描述下面过程的行为： (define (a-plus-abs-b a b) ((if (&gt; b 0) + -) a b)) 根据b的值传出+/-函数 1.5有一种检测方法能够确定解释器以哪种（应用/正则）序求值，分别考察两种求值方式导致的后果，并做出解释。（假定if的求值规则总是一样的——谓词部分先求值，根据结果确定随后求值的子表达式） (define (p) (p)) (define (test x y) (if (= x 0) 0 y)) (test 0 (p)) 应用序求值是“先求值参数再应用”的方式，这在运行(test 0 (p))时会计算(p)而导致无限循环；而正则序求值是“完全展开再归约”，会判断(= x 0)，得到#t后输出0 1.6Alyssa看不出为何要将“if”变为一种特殊形式，整了一个船新版本if： (define (new-if predicate then-clause else-clause) (cond (predicate then-clause) (else else-clause))) 而且看起来很好用： &gt;(new-if (= 2 3) 0 5) 5 &gt;(new-if (= 1 1) 0 5) 0 她重写了求平方根的过程，如果用这个过程去算平方根，会发生什么事情呢？ (define (sqrt-iter guess x) (new-if (good-enough? guess x) guess (sqrt-iter (improve guess x) x))) 会Stack OverflowScheme的解释器是应用序求值，这意味着调用“new-if”时，它会试图先计算它的参数。在最后一个过程中，sqrt-iter过程会先计算(good-enough? guess x)、guess和(sqrt-iter (improve guess x) x)，它带头调用了它自己！ 1.7容易知道下面确定平方根是否“足够好”的过程无法确定很小的数的平方根；在现实的计算机里，算术运算并不是无限精度，这使得该过程同样无法确定很大的数的平方根。 (define (good-enough? guess x) (&lt; (abs (- (square guess) x)) 0.001)) 请解释上述论断，并举例说明之。有另一种检测方式，就是监视猜测值和猜测值的迭代的变化情况。请设计一个采用这种测试方式的平方根过程，并确认是否有题干中过程的缺陷。 以下是一个使用题干过程的sqrt过程 (define (avg x y)(/ (+ x y) 2)) (define (sqrt-1 x) (define (improve guess x) (avg guess (/ x guess))) (define (good-enough? guess x) (&lt; (abs (- (* guess guess) x)) 0.001)) (define (sqrt-iter guess x) (if (good-enough? guess x) guess (sqrt-iter (improve guess x) x))) (sqrt-iter 1.0 x)) &gt;(sqrt 0.0001) 0.03230844833048122 &gt;(sqrt 1000000000) 死循环 以下是采用新方式的sqrt过程 (define (improve guess x) (/ (+ guess (/ x guess)) 2)) (define (sqrt-2 x) (define (good-enough? guess1 guess2) (&lt; (/ (abs (- guess1 guess2)) guess2) (/ 0.001 guess2))) (define (sqrt-iter guess1 guess2 x) (if (good-enough? guess1 guess2) guess2 (sqrt-iter guess2 (/ (+ guess2 (/ x guess2)) 2) x))) (sqrt-iter 0.0 1.0 x)) &gt;(sqrt 0.0001) 0.010000714038711746 &gt;(sqrt 1000000000) 31622.776601683792 1.8立方根的牛顿法是这样的：如果y是x的立方根近似值，那么(x/y^2+2*y)/3是一个更好的立方根近似值，请整一个cube-iter。 (define (improve y x) (/ (+ (/ x (* y y)) (* 2 y)) 3)) (define (good-enough? guess1 guess2) (&lt; (/ (abs (- guess2 guess1)) guess1) 0.001)) (define (cube-iter guess x) (if (good-enough? guess (improve guess x)) guess (cube-iter (improve guess x) x))) (define (cube x) (cube-iter 1.0 x)) &gt;(cube 27) 3.001274408","tags":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/tags/计算机/"}]}]