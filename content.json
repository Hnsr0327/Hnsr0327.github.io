[{"title":"SICP 1-3 Exercise | SICP第一章第三节习题","date":"2020-04-25T14:30:27.000Z","path":"2020/04/SICP-1-3-Exercise/","text":"花白的SICP之旅（3） 用高阶函数做抽象本节展示了高阶过程（操作过程的过程）如何能成为强有力的抽象机制，极大增强该语言的表述能力。以下为本节的示例代码 (define (sum-integers a b) (if (&gt; a b) 0 (+ a (sum-integers (inc a) b))));从a加到b，注意观察形式 (define (sum-cubes a b) (if (&gt; a b) 0 (+ (cube a) (sum-cubes (inc a) b))));从a^3加到b^3，注意观察形式 (define (sum-pi a b);书上是pi-sum (if (&gt; a b) 0 (+ (/ 1.0 (* a (+ a 2))) (sum-pi (+ a 4) b))));非常缓慢地收敛到Π/8，注意观察形式 (define (&lt;name&gt; a b) (if (&gt; a b) 0 (+ (&lt;term&gt; a) (&lt;name&gt; (&lt;next&gt; a) b))));公共模式 (define (sum term a next b) (if (&gt; a b) 0 (+ (term a) (sum term (next a) next b))));“表达求和的概念” (define (sum-cubes a b) (sum cube a inc b)) (define (sum-pi a b) (define (term x) (/ 1.0 (* a (+ a 2)))) (define (next x) (+ x 4)) (sum term a next b)) (define (integral f a b dx);求f函数在a到b之间的定积分近似值 (define (add-dx x) (+ x dx)) (* (sum f (+ a (/ dx 2.0)) add-dx b) dx)) &gt;(integral cube 0 1 0.01);求f=x^3在(0,1)的定积分值 0.24998750000000042","tags":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/tags/计算机/"}]},{"title":"SICP 1-2 Exercise | SICP第一章第二节习题","date":"2020-04-19T06:57:12.000Z","path":"2020/04/SICP-1-2-Exercise/","text":"花白的SICP之旅（2） 过程和产生的计算我们考察了一些简单过程产生的计算过程的“形状”，同时研究这些计算过程消耗各种重要计算资源（时间和空间）的“速率”。这一节的过程都是非常简单的，它们扮演的角色相当于摄影术的测试模式——极度简化且本身并不实际。 1.9下面这两个过程各定义了一种加法，它们基于过程inc（它将参数加1）和dec（它将参数减1） (define (+1 a b) (if (= a 0) b (inc (+1 (dec a) b)))) (define (+2 a b) (if (= a 0) b (+2 (dec a) (inc b)))) 请用代换模型展示这两个过程在求值(+ 4 5)时所产生的计算过程。这些计算过程是递归的/迭代的吗？第一个过程是这样的，是递归计算过程计算过程中有“伸展”和“收缩”的过程，且伸展过程所需要的计算量和存储空间都和参数有关 (+ 4 5) (inc (+ 3 5)) (inc (inc (+ 2 5))) (inc (inc (inc (+ 1 5)))) (inc (inc (inc (inc (+ 0 5))))) (inc (inc (inc (inc 5)))) (inc (inc (inc 6))) (inc (inc 7)) (inc 8) 9 第二个过程是这样的，是迭代计算过程计算过程中没有上述过程，需要的存储空间是常数项，计算量和参数有关 (+ 4 5) (+ 3 6) (+ 2 7) (+ 1 8) (+ 0 9) 9 1.10下面这个过程计算一个称为Ackermann函数的数学函数： (define (A x y) (cond ((= y 0) 0) ((= x 0) (* 2 y)) ((= y 1) 2) (else (A (- x 1) (A x (- y 1)))))) 请求(A 1 10)(A 2 4)(A 3 3)，并给出下面的过程对给定整数值n所计算的函数的数学定义 (define (f n) (A 0 n)) (define (g n) (A 1 n)) (define (h n) (A 2 n)) (A 1 10)、(A 2 4)和(A 3 3)过程如下： &gt;(A 1 10) (A 0 (A 1 9)) (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1)))))))))) (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2))))))))) 1024 &gt;(A 2 4) (A 1 (A 2 3)) (A 1 (A 1 (A 1 (A 2 1)))) (A 1 (A 1 (A 1 2))) (A 1 (A 1 (A 0 (A 1 1)))) (A 1 (A 1 4)) (A 1 16) 65536 &gt;(A 3 3) (A 2 (A 3 2)) (A 2 (A 2 (A 3 1))) (A 2 (A 2 2)) 65536 (f n)=2n，(g n)=2^n，(h n)=2^(2^n))。 1.11函数f由如下规则定义：如果n&lt;3，f(n)=n；否则f(n)=f(n-1)+2*f(n-2)+3*f(n-3)请分别采用递归计算过程和迭代计算过程写计算f(n)的过程。递归计算过程 (define (f x) (cond ((&lt; x 3) x) (else (+ (f (- x 1)) (* 2 (f (- x 2))) (* 3 (f (- x 3))))))) 迭代计算过程 (define (g x3 x2 x1) (+ x3 (* 2 x2) (* 3 x1))) (define (f x) (define (f-iter x1 x2 x3 count mx) (cond ((&lt; mx 3) mx) ((&lt; count mx) (f-iter x2 x3 (g x3 x2 x1) (inc count) mx)) ((= count mx) x2) )) (f-iter 1 2 4 2 x)) 1.12已知有一个杨辉三角，请写一个计算杨辉三角的元素的递归计算过程。 (define (pas row col) (define (fac x) (define (fac-w output count mx) (if (&gt; count mx) output (fac-w (* count output) (inc count) mx))) (fac-w 1 1 x)) (define r (dec row)) (define c (dec col)) (if (or (&gt; col row) (&lt; col 0)) 0 (/ (fac r) (* (fac c) (fac (- r c))))) ) 1.13证明Fib(n)（斐波那契数列的第n项）是最接近((sqrt(5)+1)/2)^n/sqrt(5)的整数。提示：先用数学归纳法证明Fib(n)=(((sqrt(5)+1)/2)^2-((sqrt(5)-1)/2)^2)/sqrt(5) 解图 1.14已知一个“给定任意钱数，给出将其换成(50/25/10/5/1)元的组合方式个数”的过程 (define (count-change amount) (define (value kind-of-coins) (cond ((= kind-of-coins 5) 50) ((= kind-of-coins 4) 25) ((= kind-of-coins 3) 10) ((= kind-of-coins 2) 5) ((= kind-of-coins 1) 1) ) ) (define (cc amount kind-of-coins) (cond ((= amount 0) 1) ((or (&lt; amount 0) (= kind-of-coins 0)) 0) (else (+ (cc amount (dec kind-of-coins)) (cc (- amount (value kind-of-coins)) kind-of-coins) )) ) ) (cc amount 5)) &gt;(count-change 400) 26517 请以树的形式画出“count-change过程在将11元换成硬币时产生的计算过程”这个计算过程的空间和步数增长的阶各是什么？ 计算过程图空间的最大使用量即是树的最大层数，此处层数的快速增长来自(n 1)-&gt;(n 0)+(n-1 1)，很明显空间增长的阶为Θ(n)考察(cc amount x)中x参数对时间复杂度的影响：当x=1时，计算量约为amount*2，此时为Θ(n)；当x=2时，(cc amount 2)会“分裂”成(cc amount 1)和(cc amount-5 2)，也就是说x=2的增长速度相比x=1多了amount倍；当x=3时，(cc amount 3)同样会“分裂”，我们会发现x=n+1的步数增长是x=n的amount倍；即题干中(count-change amount)即(cc amount 5)的步数增长阶为Θ(n^5)。但是在比较小的“找零”中，增长阶并没有达到Θ(n^5) 1.15在弧度制的角x足够小时，其正弦值可以用sinx≈x计算，有三角恒等式sinx=3sin(x/3)-4sin(x/3)^3可以减小sin的参数大小（这道习题以不超过0.1弧度为“足够小”），这个想法体现在下述过程： (define (sine angle) (define (cube x) (* x x x)) (define (p x) (- (* 3 x) (* 4 (cube x)))) (if (not (&gt; (abs angle) 0.1)) angle (p (sine (/ angle 3.0))))) 请问：a)在求值(sine 12.15)时，p调用了多少次？b)在求值(sine a)时，由过程sine所产生的计算过程使用的空间和步数（作为a的函数）增长的阶是什么？ a)12.15-&gt;4.05-&gt;1.35-&gt;0.45-&gt;0.15-&gt;0.05，即p调用了5次；b)易得参数(a)每增长到原来的3倍，递归深度加一，即增长的阶为Θ(logn)。 1.16请定义一个过程，它能产生出一个“按照迭代方式，使用一系列求平方，就像只用对数个步骤的fast-expt”的求幂计算过程。 (define (fast-expt a n) (define (square x) (* x x)) (define (even? n) (= (remainder n 2) 0)) (cond ((= n 0) 1) ((even? n) (square (fast-expt a (/ n 2)))) (else (* a (fast-expt a (- n 1)))))) 提示Ⅰ：请利用好关系(a^(n/2))^2=(a^2)^(n/2)，除了指数n和基数a以外，还应维持一个附加的状态变量b，定义好状态变换，使得状态转移时b*a^n不变。计算开始时b=1，结束时输出b。提示Ⅱ：“定义一个不变量，要求它在状态间保持不变”是思考迭代算法设计问题时的强力方法。 (define (iter-expt a n) (define (square x) (* x x)) (define (even? n) (= (remainder n 2) 0)) (define (expt a n b) (cond ((= n 0) b) ((even? n) (expt (square a) (/ n 2) b)) ((not (even? n)) (expt a (- n 1) (* b a))) ) ) (expt a n 1)) 1.17本节（1.2.4 求幂）的求幂算法的基础是通过反复做乘法求乘幂。类似的是，我们可以通过反复加法的方式求出乘积。下面的乘积过程与expt过程类似（假定该语言没有乘法）： (define (expt b n) (if (= n 0) 1 (* b (expt b (- n 1))))) (define (multi a b) (if (= b 0) 0 (+ a (multi a (- b 1))))) 该算法的计算量相对于b是线性的，假定有过程double（它将参数乘以2）和halve（它将偶数参数除以2），请用+、-、double和halve设计类似1.16的求乘积过程。 (define (multi a b) (define (double n) (+ n n)) (define (halve n) (/ n 2)) (define (even? n) (= (remainder n 2) 0)) (cond ((= b 1) a);a*1=a ((even? b) (multi (double a) (halve b)));a*b=(a*2)*(b/2) (else (+ (multi a (- b 1)) a));a*b=a*(b-1)+a ) ) 1.18请用1.16和1.17的结果，限定（+、-、double、halve），用对数步数求出两个数的乘积（注：此处应是用迭代过程重写1.17过程） (define (iter-multi a b) (define (double n) (+ n n)) (define (halve n) (/ n 2)) (define (even? n) (= (remainder n 2) 0)) (define (multi a b u) (cond ((= b 0) u) ((even? b) (multi (double a) (halve b) u)) (else (multi a (- b 1) (+ u a))))) (multi a b 0)) 1.19存在一种对数步数求Fib(n)的巧妙算法。我们已经知道旧fib-iter过程中a和b的变换规则为a←a+b和b←a，我们现在管这个变换叫T变换。通过观察可以发现，从(a,b)=(1,0)开始做N次T变换，可以得到(a,b)=(Fib(n+1),Fib(n))，换言之斐波那契数可以通过应用于(1,0)的T^n（T变换的n次方）来求得。现在我们重新定义T变换是变换族Tpq的特别种（p=0,q=1），Tpq是(a,b)→(bq+aq+ap,bp+aq)的变换。(a)请证明：如果应用变换Tpq两次，效果相当于应用同样形式的一次变换Tp’q’，其中的p’和q’可以算出来；(b)这指明了求出该变换的平方的路径，我们可以通过连续求平方的方式计算T^n。将1.16~1.18集合在一起，我们可以写出下面的“对数求出Fib(n)”的过程。请补全该过程 (define (fib-old n) (define (fib-iter a b count) (if (= count 0) b (fib-iter (+ a b) a (- count 1)))) (fib-iter 1 0 n)) (define (fib n) (define (fib-iter a b p q count) (cond ((= count 0) b) ((even? count) (fib-iter a b ??FILL-THIS-IN?? ; compute p&#39; ??FILL-THIS-IN?? ; compute q&#39; (/ count 2))) (else (fib-iter (+ (* b q) (* a q) (* a p)) (+ (* b p) (* a q)) p q (- count 1))))) (fib-iter 1 0 0 1 n)) (a)(a,b)→两次Tpq变换→(2bpq+2apq+2aq^2+bq^2+ap^2,2apq+aq^2+bq^2+bp^2)=(bq’+aq’+ap’,bp’+aq’)，观察得p’=p^2+q^2,q’=q^2+2pq。(b)我们现在可以用这个方法了——n是偶数时，求一次变换的平方并减半n，n是奇数时，运用一次变换并减少n。 (define (fib-ultra n) (define (fib-iter a b p q count) (cond ((= count 0) b) ((even? count) (fib-iter a b (+ (* p p) (* q q)) ; compute p&#39; (+ (* q q) (* 2 (* p q))) ; compute q&#39; (/ count 2))) (else (fib-iter (+ (* b q) (* a q) (* a p)) (+ (* b p) (* a q)) p q (- count 1))))) (fib-iter 1 0 0 1 n)) 1.20一个过程所产生的计算过程当然依赖于解释器所使用的规则。考虑这个迭代式gcd过程： (define (gcd a b) (if (= b 0) a (gcd b (remainder a b)))) 假定解释器用书上1.1.5节的正则序（完全展开再归约）解释这一过程（if的求值规则总是“谓词部分先行求值，根据结果再确定随后求的是哪个子表达式”）。请采用正则序的代换方法，展示(gcd 206 40)的计算过程，并指明实际执行的remainder运算。其中实际执行了多少次remainder运算？如果采用应用序（先求值参数再应用）求值呢？ &gt;(gcd 206 40);正则序 (gcd 40 (remainder 206 40));(gcd 40 6) (if (= (remainder 206 40) 0) 40 (gcd (remainder 206 40) (remainder 40 (remainder 206 40))));1次 (gcd (remainder 206 40) (remainder 40 (remainder 206 40)));(gcd 6 4) (if (= (remainder 40 (remainder 206 40)) 0) (remainder 206 40) (gcd (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))));2次 (gcd (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))));(gcd 4 2) (if (= (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) 0) (remainder 40 (remainder 206 40)) (gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))));4次 (gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))));(gcd 2 0) (if (= (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) 0) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) ......));7次 (remainder (remainder 206 40) (remainder 40 (remainder 206 40)));4次 2;总共18次，实际执行的部分有if部分先行求值的14次和最后结果的4次 &gt;(gcd 206 40);应用序 (gcd 40 6);1次 (gcd 6 4);1次 (gcd 4 2);1次 (gcd 2 0);1次 (if (= 0 0) 2 (gcd 0 (remainder 2 0))) 2;总共4次 1.21用smallest-divisor过程找出下面各数的最小因子：199、1999、19999 (define (prime? n) (define (smallest-divisor n) (define (divides? a b) (= (remainder b a) 0)) (define (find-divisor n test-divisor) (cond ((&gt; (square test-divisor) n) n) ((divides? test-divisor n) test-divisor) (else (find-divisor n (+ test-divisor 1))))) (find-divisor n 2)) (= n (smallest-divisor n))) 略（199、1999、7） 1.22大部分Lisp实现都包含一个runtime基本过程，调用它将返回一个整数，表示系统已经运行的时间。对整数n调用下面的timed-prime-test过程时将打印出n并检查n是否为素数。如果n是素数，过程将打印出三个星号和“执行这一检查所用的时间量”。 (define (timed-prime-test n) (newline) (display n) (start-prime-test n (runtime))) (define (start-prime-test n start-time) (if (prime? n) (report-prime (- (runtime) start-time)))) (define (report-prime elapsed-time) (display &quot; *** &quot;) (display elapsed-time)) 请利用这一过程写一个search-for-primes过程，它检查给定范围内连续的各个奇数的素性。请用你写的过程找出大于百/千/万/十万亿的三个最小的素数，并注意其中检查每个素数所需要的时间。已知这一检查算法具有Θ(sqrt(n))的增长阶，你可以期望在千亿附近的素数检查的耗时大约是在百亿附近的素数检查的3.16倍。你得到的数据确实如此吗？那么对于十万亿和万亿得到的数据可以支持这个预测吗？有人说程序在机器上运行的时间正比于计算所需的步数，你得到的结果符合这种说法吗？原题目为1000/10000/100000/1000000，但是由于现在计算机性能高涨，只能加七个0以产生显著影响 (define (timed-prime-test n) (define (start-prime-test n start-time) (define (report-prime elapsed-time n) (newline) (display n) (display &quot; *** &quot;) (display elapsed-time)) (if (prime? n) (report-prime (- (runtime) start-time) n))) (start-prime-test n (runtime))) (define (prime? n) ......);略 (define (search-for-primes a b) (define (primetest i y) (if (not (&gt; i y)) (timed-prime-test i)) (if (not (&gt; i y)) (primetest (+ i 2) y))) (primetest (if (= (remainder a 2) 0) (+ a 1) a) b)) (search-for-primes 10000000000 10000000100);7.0ms (search-for-primes 100000000000 100000000100);20.7ms (search-for-primes 1000000000000 1000000000100);69.2ms (search-for-primes 10000000000000 10000000000100);231.7ms 找素数略耗时的预测在十万亿和千亿/万亿和百亿大致正确。 1.231.21中的smallest-divisor过程做了许多无用检查：在其检测完2以后，不应该再检测任何偶数。我们希望test-divisor所用的值是（2、3、5、7、9……）。请实现这种修改，其中定义一个过程next：输入2时输出3，其他时候输出输入的数加2。运行1.22找素数测试。这一修改使检查的步数少了一半，你可能期待其运行速度快一倍，实际情况符合这一预期吗？如果不符合，两个算法的速度比值是多少？如何解释比值不等于2？ (define (prime? n) (define (smallest-divisor n) (define (next x) (cond ((&gt; x 2) (+ x 2)) (else 3))) (define (divides? a b) (= (remainder b a) 0)) (define (find-divisor n test-divisor) (cond ((&gt; (square test-divisor) n) n) ((divides? test-divisor n) test-divisor) (else (find-divisor n (next test-divisor))))) (find-divisor n 2)) (= n (smallest-divisor n)));外部测时间略 (search-for-primes 10000000000 10000000100);3.8ms (search-for-primes 100000000000 100000000100);13.0ms (search-for-primes 1000000000000 1000000000100);40.9ms (search-for-primes 10000000000000 10000000000100);164.2ms 并不符合该预期，速度比值约为1.5。因为只有这个步骤得到了加速。 1.24修改练习1.22中的timed-prime-test过程，让它使用fast-prime?（费马方法）；运行1.22找素数测试。这一修改让素数测试具有仅仅Θ(logn)的增长速度，你对接近一亿的素数检查和接近一万的素数检查的期望时间比值有何预期？数据表明预期了吗？你能解释不符合预期的地方吗？ (define (search-for-primes a b) (define (timed-prime-test n) (define (fast-prime? n times) (define (fermat-test n) (define (expmod base exp m) (define (square x) (* x x)) (cond ((= exp 0) 1) ((even? exp) (remainder (square (expmod base (/ exp 2) m)) m)) (else (remainder (* base (expmod base (- exp 1) m)) m)) )) (define (try-it a) (= (expmod a n n) a)) (try-it (+ 1 (random (- n 1))))) (cond ((= times 0) true) ((fermat-test n) (fast-prime? n (- times 1))) (else false))) (define (start-prime-test n start-time) (define (report-prime elapsed-time n) (newline) (display n) (display &quot; *** &quot;) (display elapsed-time)) (if (fast-prime? n 10000);被人为调大 (report-prime (- (runtime) start-time) n))) (start-prime-test n (runtime))) (define (primetest i y) (if (not (&gt; i y)) (timed-prime-test i)) (if (not (&gt; i y)) (primetest (+ i 2) y))) (primetest (if (= (remainder a 2) 0) (+ a 1) a) b)) (search-for-primes 10000 10100);23ms (search-for-primes 100000000 100000100);47ms 由这几题可以发现：使用计算步数最多只能“大致预测”程序的运行时间，而算法复杂度是用于评价算法思想“好”的程度的。即使我们计算出来某程序的计算步数，也会由于各种原因——电脑CPU主频的高低、当前系统的拥堵程度、编译器/解释器的优化效率等等——使得计算步数无法对应到最终的运行时间。而算法复杂度更为简单：它估计的是计算步数（空间）的规模随参数的变化而变化的程度。大多数情况下，如果A算法比B算法复杂度低，在参数较小时B可能快于A，但是在参数足够大时，A算法的优势将体现出来。 1.25有人说在费马测试中的expmod中，我们做了很多的额外工作，我们应该这么写expmod： (define (fast-expt a n) (define (square x) (* x x)) (define (even? n) (= (remainder n 2) 0)) (cond ((= n 0) 1) ((even? n) (square (fast-expt a (/ n 2)))) (else (* a (fast-expt a (- n 1)))))) (define (expmod base exp m) (remainder (fast-expt base exp) m)) 请问：这句话对吗？这个过程可以很好地用于我们的快速素数检查程序吗，为什么？不对。我们仔细阅读费马测试中的代码，会发现exp数值有时候会很大（比如数万），此时原版代码将乘幂减少到可以计算的程度再计算，而这里将会粗暴地计算数十亿的数万次方，计算量会大到难以想象。 1.26有人在做练习1.24的时候遇到了困难：他的fast-prime?比原来的prime?还要慢。他的朋友在检查他的代码时发现他重写了expmod过程，其中用了一个乘法代替square过程： (define (expmod base exp m) (define (square x) (* x x)) (cond ((= exp 0) 1) ((even? exp) (remainder (* (expmod base (/ exp 2) m);changed (expmod base (/ exp 2) m)) m)) (else (remainder (* base (expmod base (- exp 1) m)) m)) )) 这个人如此解释：“我看不出来这会造成什么不同。”而朋友一语道破：“你采用这种方式写这个过程时，就把Θ(logn)的过程变成Θ(n)的了。”请解释这段话。让我们假定我们是一台电脑，即将计算(expmod 2 1024 10)若使用旧的expmod过程，我们将会遇到(square (expmod 2 512 10))，只要计算一次下级的expmod；而题干的expmod过程将会让我们计算两次(expmod 2 512 10)。到最后，旧过程约10次能干完，新过程却要1024次才能干完，对数型增长变成了线性增长。 1.27证明脚注47*中列出的Carmichael数确实能骗过费马检查。为了证明这一点，你可以写一个过程，输入整数n，对每个a&lt;n检查a^n是否与a模n同余。*能骗过费马检查的数称为Carmichael数，只知道它非常罕见。在一亿之内只有255个这种数 (define (ultra-prime? n) (define (fermat-test n) (define (expmod base exp m) (define (square x) (* x x)) (cond ((= exp 0) 1) ((even? exp) (remainder (square (expmod base (/ exp 2) m)) m)) (else (remainder (* base (expmod base (- exp 1) m)) m)) )) (define (try-it a) (= (expmod a n n) a)) (try-it (+ 1 (random (- n 1))))) (define (prime? x y n) (cond ((not (&lt; x y)) true) ((not (fermat-test n)) false) (else (prime? (+ x 1) y n)))) (prime? 0 n n));超级素数筛法 (ultra-prime? 561);#t (ultra-prime? 1105);#t (ultra-prime? 1729);#t (ultra-prime? 2465);#t (ultra-prime? 2821);#t (ultra-prime? 6601);#t;超级筛法反而没用了 1.28费马检查的一种不会被欺骗的变形为Miller-Rabin检查，它来源于费马小定理的一个变形。这个变形断言：如果n是素数，那么任何小于a的整数的n-1次幂与1模n同余。要用该检查方法考察n的素性，我们应该随机抽取数a\\&lt;n并用expmod求a的n-1次幂对n的模。然而，在执行expmod中的平方步骤时，我们需要查看是否遇到了“1取模n的非平凡平方根”，也就是说，是不是存在不等于1或者n-1的数，其平方取模n等于1。可以证明，如果1的这种非平凡平方根存在，那么n就不是素数。还可以证明，如果n是非素数的奇数，那么至少有一半的数a\\&lt;n，按照这种方式计算a^(n-1)，将会遇到1取模n的非平凡平方根。这也是该检查不会受骗的原因。请修改expmod过程，让它在发现1的非平凡平方根时报告失败，并利用它实现一个类似于fermat-test的过程，完成Miller-Rabin检查。通过检查一些已知素数和非素数的方式考验你的过程。提示：送出失败信号的一种简单方式就是返回0 (define (prime? x) (define (miller-rabin-prime? n times) (define (square x) (* x x)) (define (ultra-fermat-test n) (define (nontrivial-square-roots? base m) (and (not (= base 1)) (not (= base (- m 1))) (= 1 (remainder (square base) n))) );是不是存在不等于1或者n-1的数，其平方取模n等于1 (define (expmod base exp m) (cond ((nontrivial-square-roots? (+ 1 (random (- n 1))) m) 0);是否遇到非平凡平方根 ((= exp 0) 1) ((even? exp) (remainder (square (expmod base (/ exp 2) m)) m)) (else (remainder (* base (expmod base (- exp 1) m)) m)) )) (define (try-it a) (= (expmod a (- n 1) n) 1)) (try-it (+ 1 (random (- n 1))))) (cond ((= times 0) true) ((ultra-fermat-test n) (miller-rabin-prime? n (- times 1))) (else false)));miller-rabin筛法 (miller-rabin-prime? x (ceiling (sqrt x)))) (prime? 561) (prime? 1105) (prime? 1729) (prime? 2465) (prime? 2821) (prime? 6601);Carmichael 全为#f (prime? 9999749);#t","tags":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/tags/计算机/"}]},{"title":"SICP 1-1 Exercise | SICP第一章第一节习题","date":"2020-04-14T15:09:12.000Z","path":"2020/04/SICP-1-1-Exercise/","text":"花白的SICP之旅（1） 程序设计的基本元素1.1下面是一堆表达式，从上到下解释器将输出什么结果？（表达式略）一系列表达式，按部就班地做就行了 1.2请将下面表达式变换为前缀形式。（表达式略）考察前缀形式表达式 1.3请定义一个过程，它以三个数为参数，返回其中较大的两个数的平方和。（汉化版缺了“平方”） (define (Y a b c) (cond ((and (&lt; c b) (&lt; c a)) (+ a b)) ((and (&lt; b a) (&lt; b c)) (+ a c)) (else (+ b c)))) //平方和的话就是再加一个define 1.4考察允许运算符为符合表达式的组合式的求值模型，根据对模型的认识描述下面过程的行为： (define (a-plus-abs-b a b) ((if (&gt; b 0) + -) a b)) 根据b的值传出+/-函数 1.5有一种检测方法能够确定解释器以哪种（应用/正则）序求值，分别考察两种求值方式导致的后果，并做出解释。（假定if的求值规则总是一样的——谓词部分先求值，根据结果确定随后求值的子表达式） (define (p) (p)) (define (test x y) (if (= x 0) 0 y)) (test 0 (p)) 应用序求值是“先求值参数再应用”的方式，这在运行(test 0 (p))时会计算(p)而导致无限循环；而正则序求值是“完全展开再归约”，会判断(= x 0)，得到#t后输出0 1.6Alyssa看不出为何要将“if”变为一种特殊形式，整了一个船新版本if： (define (new-if predicate then-clause else-clause) (cond (predicate then-clause) (else else-clause))) 而且看起来很好用： &gt;(new-if (= 2 3) 0 5) 5 &gt;(new-if (= 1 1) 0 5) 0 她重写了求平方根的过程，如果用这个过程去算平方根，会发生什么事情呢？ (define (sqrt-iter guess x) (new-if (good-enough? guess x) guess (sqrt-iter (improve guess x) x))) 会Stack OverflowScheme的解释器是应用序求值，这意味着调用“new-if”时，它会试图先计算它的参数。在最后一个过程中，sqrt-iter过程会先计算(good-enough? guess x)、guess和(sqrt-iter (improve guess x) x)，它带头调用了它自己！ 1.7容易知道下面确定平方根是否“足够好”的过程无法确定很小的数的平方根；在现实的计算机里，算术运算并不是无限精度，这使得该过程同样无法确定很大的数的平方根。 (define (good-enough? guess x) (&lt; (abs (- (square guess) x)) 0.001)) 请解释上述论断，并举例说明之。有另一种检测方式，就是监视猜测值和猜测值的迭代的变化情况。请设计一个采用这种测试方式的平方根过程，并确认是否有题干中过程的缺陷。 以下是一个使用题干过程的sqrt过程 (define (avg x y)(/ (+ x y) 2)) (define (sqrt-1 x) (define (improve guess x) (avg guess (/ x guess))) (define (good-enough? guess x) (&lt; (abs (- (* guess guess) x)) 0.001)) (define (sqrt-iter guess x) (if (good-enough? guess x) guess (sqrt-iter (improve guess x) x))) (sqrt-iter 1.0 x)) &gt;(sqrt 0.0001) 0.03230844833048122 &gt;(sqrt 1000000000) 死循环 以下是采用新方式的sqrt过程 (define (improve guess x) (/ (+ guess (/ x guess)) 2)) (define (sqrt-2 x) (define (good-enough? guess1 guess2) (&lt; (/ (abs (- guess1 guess2)) guess2) (/ 0.001 guess2))) (define (sqrt-iter guess1 guess2 x) (if (good-enough? guess1 guess2) guess2 (sqrt-iter guess2 (/ (+ guess2 (/ x guess2)) 2) x))) (sqrt-iter 0.0 1.0 x)) &gt;(sqrt 0.0001) 0.010000714038711746 &gt;(sqrt 1000000000) 31622.776601683792 1.8立方根的牛顿法是这样的：如果y是x的立方根近似值，那么(x/y^2+2*y)/3是一个更好的立方根近似值，请整一个cube-iter。 (define (improve y x) (/ (+ (/ x (* y y)) (* 2 y)) 3)) (define (good-enough? guess1 guess2) (&lt; (/ (abs (- guess2 guess1)) guess1) 0.001)) (define (cube-iter guess x) (if (good-enough? guess (improve guess x)) guess (cube-iter (improve guess x) x))) (define (cube x) (cube-iter 1.0 x)) &gt;(cube 27) 3.001274408","tags":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/tags/计算机/"}]},{"title":"20 Feb 20 | 二零年二月二十日","date":"2020-02-20T15:29:16.000Z","path":"2020/02/20-Feb-20/","text":"对过去十个月，花白的事件的概括 今天Godaddy发来了这个域名的账单，突然发现已经有将近十个月没有更新网站了……先对之前发生了什么做个summary吧。 六月份高考，成功考砸去（一所很奇怪的）普通一本院校， 暑期空闲考驾照成功， 大学第一学期绩点3.2x，有很大的进步空间 不理想， 认识了现在的男友 Philis ， 开始在部分指导下学习计算机。 还有其它一些事情，就不打了……","tags":[{"name":"杂事","slug":"杂事","permalink":"http://yoursite.com/tags/杂事/"}]},{"title":"Turbulent May | 多事五月","date":"2019-06-19T15:52:42.000Z","path":"2019/06/Turbulent-May/","text":"事实上五六月份的事情都很多……春夏之交的周年庆与我关涉密切的倒不太多也不甚重要（如果高考不算的话x） 这两天，可喜可贺的，邢嘉和又多了一个新女友！（大约）空窗期比我预想得稍微长了一点，希望他这回可以长长记性，不要犯错了。↑但凭他固执的性格……所以说，我的邢学家生涯暂时结束辽，高考结束以后会整理好放在这里 说起来……高考迫近的感觉其实没多少。因为浙大大概是很难上了，也无所谓了。（2019-06-01 21:03:30） 高考结束12天，闲在家中（怎么还是五月x）。←不是重点观测得Xing正推广其推特，因此关闭Brocaproof，给他一个惊喜。明日方舟还算好玩，就是氪金体验极差，甚至不如丢到A股打水漂。","tags":[{"name":"杂事","slug":"杂事","permalink":"http://yoursite.com/tags/杂事/"}]},{"title":"Recent Hanashiro | 最近的花白","date":"2019-04-20T14:23:23.000Z","path":"2019/04/Recent-Hanashiro/","text":"50mg的Androcur副作用会不会太大了……？但之前的用量一贯如此啊。有点累了。※动态内容，可通过注释来看到其时间。 大约……还有37天就高考了。接下来要把语文的套路题解决掉，上115。数学坚决不能犯错，前面的每一题都得对（话是这么说但每次都得扣3~4分）。英语随缘，实在是达不到他的外语水平。 虽然想做的事还有很多，幻想的内容越发阴暗，但……现在是要先考试的吧，管不了那么多了。 最近盘旋在脑海里的，是考砸的选考，和已经变质的「初恋」的记忆。离终点站还有46天，朋友一个一个地减少，不论是M，还是D、X、H，都逐渐消失了。本来要把和他第一次做爱的细节尽数记下，但记忆单元的损耗程度超过想象。可能跟他说的一样吧……「你的脑子，真的是……无可救药」。 罢了，还是先准备考试了，如果……能上670的话，就挺好。（话是这么说，结果打了一上午的牌x）","tags":[{"name":"杂事","slug":"杂事","permalink":"http://yoursite.com/tags/杂事/"}]},{"title":"The Afternoon | 某个下午","date":"2019-03-30T13:03:30.000Z","path":"2019/03/The-Afternoon/","text":"如果没有2.5mg的地西泮的话，这段诡异的恋爱就没有开始的机会了。也许是R15，还是R17？不知道呢。 二零一八年十二月九日十点，我看了一下表，自知已经迟到，便不紧不慢地跑着。不知多久，我跑到了他的小区门口，刚好被他接进家里了。「这个是礼物」我把装有白色粉末的离心管递给他。「大概要多少才会…？」「只要两百毫克吧……不过这个有点泛黄，不大纯」交流着化学品的相关参数，走进了他的家。 「没有估错的话，大约六十平」，我环顾四周，快速地在心里测算着。有我家没有的客厅，电视很小，饭桌和卧室比较小，客厅角落里塞满了速食品和他的包装食材；厨房和卫生间的门口都挂着奇怪的帘子，一眼能望到的还有他父母的朴素卧室，勉强够两个人睡。「还有东西要给你」将身上的一件件东西褪下（还有我的红色（女生）校服），取出一份碟片。「我很喜欢它，希望你也是」递给他以后，又补了一句话，「这上面全是日文，我看不懂，这些你应该是会的」「有点冷，进来坐坐吧，我开了暖气」突然意识到之后预定的议程，他带着我进了房间。 很暖和，被子被杂乱地堆放在床上，地上堆满了东西，有书柜和书架各一个，排列满了书籍。在（俯视图的右上角）右前方摆放着玻璃橱柜，里面塞满了各种奇怪物件：平常只有体检时才会看到的真空采血管和一次性采血针、橡胶手套若干、毛笔几只……在床的左方是他的一台笔电，开满了软件。但最吸引我注意力的还是书架上的《大问题》——哲学社社长戴路推荐过的。「啊，这本吗？你拿去看吧，反正我看完了」（至于现在嘛，它已经作为归属未明的财产被放在抽屉里了）他点开了华农兄弟的一个视频，我正兴奋于书籍本身，偶尔抬头，被他嫌弃了。视频结束，似乎打算去做饭，但有点犹豫。「有一件很重要的事情想跟你说，但我希望在吃完以后再公布」 作者注：这段中我的实际思考能力被拔高了 「那你现在说啊，为什么现在不行？」「你还记得M吗？」M是我的初中同学，我正是因为M的关系和他相识，同时……M还是我的单相思对象。「他……怎么了？」虽然当时我的脑子已经被镇定剂严重限制了思维速度，不安感渐渐升起。「在今年的6月初……」「还是在这间房，我跟他做过了，而且……」看着逐渐崩溃的我，他平静地陈述着，「他看起来还挺享受的。」「……还有吗？」突然，我对情感的破裂不再关心，因为我的逻辑轴线尚待补全——就差这一个。「具体的时间嘛……在6月7号。如果你要问最后发生了什么，他在我嘴里射了，仅此而已」够了。我把头埋在手里，心里却在将剩余的拼图一个个补全。「这件事以后，我跟他的关系变得很尴尬，大概是做不成朋友了」，「一致」我心里暗自说着。「因为各种各样的事情，我现在已经没有几个朋友了」他稍微靠近了我一点。「所以，」我竭力假装不在乎事实的表情，「你之前的男朋友呢？」「早就跟他分了」仍然是平静的语气。镇定剂的作用似乎突然消失，我在逻辑之海中连出了一条线。「他为什么要在生日后还要叫我到他的家里，说他和我单相思对象做过爱的事实？」长久的沉默。「你还记得你前几天说过什么吗？」他突然发问。「是关于朋友间的权限问题，比如能不能叫你『嘉和』」药物的反扑作用使我只能艰难地简单作答。「所以说……你知道我想要你的什么吗？」「上回见面的时候，我觉得花白很可爱」「我想要你身体的所有权限，作为回报，我将会在毕业之前，给你你所需要的关心和温暖。」 我当时懵了，之前从来没有人这么跟我说过「我喜欢你」之类的话，而且这个人还……但现实毕竟不是漫画，没等我明白到底发生了什么，他就把我拉到面前。「他怎么离我这么近…」我必须承认的是，当时不带眼镜的邢嘉和真的很可爱——以至于我卸下了所有防备，「等等，不会是…」他温软的嘴唇贴了上来， ———— （仍然在施工中） ————","tags":[{"name":"往事","slug":"往事","permalink":"http://yoursite.com/tags/往事/"}]},{"title":"History of Broca | 邢嘉和史","date":"2019-03-23T11:02:26.000Z","path":"2019/03/History-of-Broca/","text":"初恋。欲望的机器。 171118—181209 联系人181209—190226 「恋人」至今 陌路人 前年的11月18号认识，因一个奇怪巧合[1]互相加QQ。很长时间里都是普通的联系人[2]。交流化学竞赛的内容，描述一下各自学校的状态。在去年的11月17号里看了一部电影。12月9号到他家里……被攻略成恋人了。中间见过几次面，甚至还拍了一张照片（他不让拍照所以只有一张）。 照片 今年2月26号光速分手。 细节 [1]在不知道作者是他本人的情况下盛赞其视频作品[2]“偶尔你一句我一句”的那种水平，此时他曾提及「他的男朋友」，约为第三任———— （上面这些我懒得补充，可能永远在施工中） —————-他的一些方面：性：强调是顺性别双性恋男性（可能是经常被人说娘的缘故），相当渴望肉体欢愉（人形炮机）。毫无疑问，他对性的态度相当开放，同时性爱技巧丰富。截至2019年4月18日，有过四任男友与若干任女友。家庭与经济：在十来岁之前由其祖父母带大，在他们死后由原生父母供应生活。家庭财富量不详，有一套住房（约70㎡）。父亲是普通职工，母亲迷信宗教散财颇多。每月以肉体关系接受不知道第几任男友约500元的资助。个性：拒绝婚姻之类束缚自由（待定义）的事物，漠视道德。爱好广泛（高中时期曾在学校上吊未遂，因此他依情绪上课），对哲学、语言学习、政治学、心理学、性学以及其他科学[1]感兴趣。很会做饭（亲自吃过…一次x），喜欢旅游，因为性的方面热衷做爱与研究其技巧。心理：精神疾病丰富，已知材料显示其存有双向情感障碍与失眠。在连贯所有材料以后，猜测有未诊断的■■■■■■■或■■■■■■■，它们或是其恋爱经历失败的诱因。[2]游戏：狂热爱好守望先锋（屁股），在steam上实名上网。细节 [1]自称[2]未经证实","tags":[{"name":"邢嘉和|Broca-Phenol","slug":"邢嘉和-Broca-Phenol","permalink":"http://yoursite.com/tags/邢嘉和-Broca-Phenol/"},{"name":"人物剪影","slug":"人物剪影","permalink":"http://yoursite.com/tags/人物剪影/"}]},{"title":"Intro & Foreword | 简介与前言","date":"2019-03-13T12:37:21.000Z","path":"2019/03/Intro-and-Foreword/","text":"花白（はなしろ）（@hnsr0327），高三在读，大只边障儿童。 （因为我太懒了，这部分就从日记里抄下来了x） 可以从这些方面了解我： 缺乏共情，也许不算正常人类。 因为副作用处于抑郁状态，尚无解决办法。 看过一点点动画，对目前的动漫作品几乎不了解。 在国际服万智牌竞技场里打牌。（Hnsr#03444） 心理中性，喜欢男的（现在不想谈恋爱） Hs56 Pd70 Pt67 Sc61 Ma48 Mf-M57 D82 Hy75 Pa55 Si61 喜欢的颜色有 #dd3333 #cc6677。 有过一次复杂的「恋爱经历」。 化学竞赛退役，有机差两分没能省一。 大概很早时候就有在网上写点东西的想法了，但因为懒惰一直没实现。现在还没有评论区，以后会加的（大概）。我在文章里偶尔会加一些注释，需要Chrome的开发者工具（F12）。图片均已压缩，原图统一为”/pictures/***-origin.**” 本博客（日记本）的总消耗不会超过1Mbyte（不像隔壁邢嘉和的2333(目前是50倍x)）。 部分图片/音频/文字会以注释形式给出链接（或直接内容）。","tags":[{"name":"个人简介","slug":"个人简介","permalink":"http://yoursite.com/tags/个人简介/"}]}]